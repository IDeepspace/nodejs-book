## 浏览器中的事件循环机制

### 一、单线程和异步

提到 `JavaScript` ，就会想到它的 **单线程** 和 **异步** 两大特性。那么在 `JavaScript` 中单线程是如何做到异步的呢？我们先了解一下单线程和异步之间的关系。

`JavaScript` 中的任务分为 **同步** 和 **异步** 两种，它们的处理方式存在很大的不同。

#### 1、异步

**同步任务** 是直接在 **主线程** 上排队执行。在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务。所有同步任务都在主线程上执行，形成一个 **执行栈**（`execution context stack`）。

**异步任务** 则是被放在**任务队列** (`task queue`) 中，不进入主线程。如果有多个异步任务，那这些异步任务就要在任务队列中排队等候。任务队列类似一个缓冲区，任务下一步会被移到**执行栈**（`execution context stack`），然后主线程执行执行栈的任务。

主线程和任务队列的示意图：

![主线程和任务队列](./main-thread-and-task-queue.jpg)

#### 2、单线程

`JavaScript` 中其实是没有线程概念的，所谓的单线程也只是相对于多线程而言。**线程**本来就不属于 `JavaScript` 语言的范畴，只是为了和其它语言做对比而已，为了让那些用过多线程语言的人理解 `JavaScript` 的特点。

单线程是指 `JavaScript` 引擎中负责解析执行 `JavaScript` 代码的线程只有一个（**主线程**），即每次只能做一件事。

> 注意：所谓的 `JavaScript` 是单线程的，是指 `JavaScript` 运行在浏览器中是单线程的，叫做 ` JavaScript` 引擎线程。但是浏览器不是单线程的。

浏览器是**事件驱动（`Event driven`）的**。浏览器中很多异步行为都是由浏览器新开一个线程去完成的，它会创建事件并放入执行队列中。`JavaScript` 引擎是单线程处理任务队列，它只是浏览器多个线程中的一个。所以当多个事件触发时，会依次放入队列，然后一个一个响应。

浏览器还包括很多其他线程，如界面渲染线程，浏览器事件触发线程，`Http` 请求线程等。

怎么证明 `JavaScript` 是单线程的呢？ 看段代码：

```javascript
function foo() {
    console.log("first");
    setTimeout((function () {
        console.log('second');
    }), 5);
}

for (let i = 0; i < 1000000; i++) {
    foo();
}
```

上面的代码中，`JavaScript` 引擎 `5ms` 后会把打印 `second` 的任务加入队列，而当前有任务，所以只能等 `1000000` 个 `first` 打印完后才会打印 `second` 。所以执行结果会首先全部打印 `first` ，然后再全部打印 `second` ，即使中间的执行时间超过 `5ms` 。

由此可见，`JavaScript` 是单线程的。



#### 3、ajax 请求

我们知道一个当发出 `ajax` 请求的时候，主线程在等待它响应的同时是会去做其它事情的。浏览器先在事件表中注册 `ajax` 的回调函数，响应回来后回调函数被添加到任务队列中等待执行，不会造成线程阻塞，所以说 `JavaScript` 处理 `ajax` 请求的方式是异步的。



### 二、事件循环

根据上面的描述，`JavaScript` 检查执行栈是否为空，以及确定把哪个 `task` 加入执行栈的这个过程就是**事件循环**，`JavaScript` 实现异步的核心就是事件循环。

![事件循环](./eventLoop-browser.png)

主线程运行的时候，产生堆（`heap`）和栈（`stack`），栈中的代码调用各种外部 `API`，它们在 **任务队列** 中加入各种事件（`click`，`load`，`done`）。只要栈中的代码执行完毕，主线程就会去读取 **任务队列** ，依次执行那些事件所对应的回调函数。



### 三、定时器

除了放置异步任务的事件，**任务队列** 中还可以放置定时事件，即指定某些代码在多少时间之后执行。这叫作 **定时器（timer）**功能，也就是定时执行的代码。

定时器功能主要由 `setTimeout()` 和 `setInterval()` 这两个函数来完成，它们两个的内部运行机制完全一样，区别在于前者指定的代码是一次性执行，后者则为反复执行。下面看段代码：

```javascript
console.log(1);
setTimeout(function () { console.log(2); }, 1000);
console.log(3);
```

输出结果为：

```javascript
1
3
2
```

`setTimeout()` 将第二行代码推迟到 `1000ms ` 之后执行。

写 `JavaScript` 代码的时候，我们会经常将 `setTimeout()` 的第二个参数设为 `0`，就表示当前代码执行完（执行栈清空）以后，立即执行（ `0ms` 间隔）指定的回调函数。

**注意**：`setTimeout()` 只是将事件插入了 **任务队列**，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。如果当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在`setTimeout()` 指定的时间执行。